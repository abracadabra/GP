--{-# LANGUAGE Safe #-}
module GRPSeed
( act
, reprogram
, initial
--, reinforcement
) where

--ALWAYS compile results of this as Safe

import System.Random
import Data.Maybe (isJust, fromJust)
import Data.List
import GRPCommon
import Language.Haskell.Exts.Parser

reprogram :: [StdGen] -> State -> [String] -> (String, State)
act :: [StdGen] -> State -> Input -> (Output, State)
--reinforcement :: [StdGen] -> State -> Int -> String -> State
--initial :: State

{-
testrun = do
  text <- System.IO.StrictreadFile "./GRPSeed.hs"
  rng <- newStdGen
  let (newcode, _) = reprogram [rng] [] [fromJust $ dropSafetyPrefix text]
  return newcode

t2 = do
  text <- System.IO.StrictreadFile "./GRPSeed.hs"
  let t2 = fromJust $ dropSafetyPrefix text
  let preproc = unwords $ {- Here be mutate -}concat $ intersperse ["\n"] $ map words $ lines t2
  return preproc
-}

--Proposal for automatic generation of Seed from SeedHR:
--strict syntax: everything that would go into one line needs to be in a consecutive block of non-empty lines
--Everything that would go into different lines needs to be interspersed with newlines in between.
--Commends may only be -- at lines beginning in the actual code part.
--This way, automatic generation of GRPSeed should be as easy as removing comments,
--  replacing newlines with spaces between non-empty lines and then removing empty lines
--TODO: code the above and automatically execute it, also: Add GRPSeed to cleanup.sh
--Once this program works by changing ASTs generated by a haskell parser, the hr version can be generated by PrettyPrint - or isn't even necessary anymore, since this interim format isn't needed anymore.

--The Danger Zone starts here. Keep the next line up to date:
safeLines = 44

act rngs state inp = ( ( take ( div ( length inp ) 2 ) inp, drop ( div ( length inp ) 2 ) inp ) , state )

reprogram ( r1 :  _ ) state ( source1 : _ ) =
  let
    candidates = map ( \ rng -> lexemlisttransform ( preproc source1 ) rng state ) ( infrg r1 )
  in ( head $ filter ( \ candidate -> ( candidate /= postproc ( preproc source1 ) ) && ( parseable candidate ) ) ( map postproc $ filter ( \ x -> True ) candidates ) , state )

parseable str = let result = parseModule str in wasSuccess result
wasSuccess ( ParseFailed _ _ ) = False
wasSuccess ( ParseOk _ ) = True

preproc str = intercalate [ "\n" ] $ map words $ lines str
postproc strs = rmlist ( \ x y -> x == '\n' && y == ' ' ) $ unwords strs

infrg rg = let ( x , y ) = split rg in x : infrg y

rmlist predicate ( x : y : ys ) = if predicate x y then rmlist predicate ( x : ys ) else x : rmlist predicate ( y : ys )
rmlist a xs = xs

initial = [ 10000000 , 20000000 ]

lexemlisttransform :: [ String ] -> StdGen -> State -> [ String ]
lexemlisttransform [] rng state = []
lexemlisttransform ( lex : lst ) rng state =
  let ( decision , rng2 ) = next rng :: ( Int , StdGen )
  in
    if decision < ( head initial )
    then let ( n , rng3 ) = next rng2 in ( lexems !! mod n ( length lexems ) ) :  lex : lexemlisttransform lst rng3 state
    else
      if decision < ( last initial )
      then lexemlisttransform lst rng2 state
      else lex : lexemlisttransform lst rng2 state
